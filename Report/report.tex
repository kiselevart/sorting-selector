\documentclass[twocolumn]{article}

\usepackage{graphicx} % Required for inserting images
\usepackage{placeins}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{listings}
\usepackage{amssymb}
\usepackage[a4paper, left=0.5in, right=0.5in, top=1in, bottom=1in]{geometry}
\usepackage{xcolor}
\usepackage{tikz}
\usepackage{float}
\usepackage{caption}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{url}
\usepackage{breakurl}
\usepackage{sectsty}
\usepackage[]{helvet}
\usepackage{titling}
\usepackage{titlesec}

\titlespacing*{\section}{0pt}{1ex}{1ex}

%\allsectionsfont{\sffamily\bfseries}
\pretitle{\begin{center}\sffamily\bfseries\Large}
\posttitle{\par\end{center}}
\preauthor{\begin{center}\sffamily\bfseries}
\postauthor{\par\end{center}}
\predate{\begin{center}\sffamily\bfseries}
\postdate{\par\end{center}}

\usetikzlibrary{automata, positioning, arrows.meta}

\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\renewcommand{\le}{\leqslant}
\renewcommand{\ge}{\geqslant}
\newcommand{\vsp}{\vspace{0.5em}}
\newcommand{\expect}{\mathbb{E}}
\newcommand{\prob}{\mathbf{P}}
\newcommand{\ruler}{
    \vspace{1em}
    \hrule
    \vspace{1em}
}
\newcommand{\bsq}{\hfill $\blacksquare$}


\lstset{
    language=C++,          % Set the language for syntax highlighting
    numbers=left,          % Display line numbers on the left
    numberstyle=\tiny\color{gray},  % Style for line numbers
    rulecolor=\color{black},         % Border color around the code block
    basicstyle=\ttfamily\footnotesize, % Set font style and size (smaller font)
    keywordstyle=\color{blue},   % Syntax highlighting for keywords
    commentstyle=\color{green},  % Syntax highlighting for comments
    stringstyle=\color{red},   % Syntax highlighting for strings
    morekeywords={auto, register, inline}, % Add extra C++ keywords if necessary
}

\title{Algorithm Selection: A Predictive Model for Optimal Sorting}
\author{Artem Kiselev}

\begin{document}

\maketitle

\section{Introduction}
Sorting is a fundamental task that appears across various applications in computer science, from database management to data analytics and real-time processing systems. Due to its critical importance, hundreds of sorting algorithms have been developed, each with unique performance characteristics optimized for particular scenarios. Some algorithms excel at sorting nearly-sorted data, others at handling large datasets, and others at optimizing memory usage. As a consequence, no single algorithm universally outperforms all others for all problem instances. This naturally leads to the following research question:

\begin{quote}
\emph{Can we design a model that dynamically and intelligently selects the optimal sorting algorithm based on the characteristics of a given dataset?}
\end{quote}

Successfully addressing this question and constructing an effective predictive model would represent a meaningful advancement. Such a model, capable of analyzing a dataset's characteristics and predicting the optimal sorting strategy based on that analysis, could deliver substantial performance improvements over current static approaches. In practical terms, this could significantly enhance efficiency in real-world scenarios, including large-scale database operations, data-intensive computations, and latency-sensitive applications, providing tangible benefits over existing sorting implementations.

\section{Problem Formalization}
This question is an instance of the algorithm selection problem, formulated by John Rice in 1976 \cite{ricealgorithmselection}. It is formally stated as follows: \\
\textbf{Given:}
\begin{itemize}
    \item A problem space $\mathcal{P}$, containing all possible problem instances.
    \item A feature space $\mathcal{F}$, where each $f(x) \in \mathcal{F}$ represents measurable characteristics of problem $x \in \mathcal{P}$.
    \item An algorithm space $\mathcal{A}$, containing all applicable algorithms $A_i$.
    \item A performance space $\mathbb{R}^n$, where $p(A_i,x)$ represents the performance of algorithm $A_i \in \mathcal{A}$ on problem $x \in \mathcal{P}$.
    \item The final algorithm performance metric $||p||$, obtained by normalizing the raw performance measures.
\end{itemize}

\noindent \textbf{Find:} A selection mapping 
\[
S: \mathcal{F} \rightarrow \mathcal{A}
\]
that maximizes performance according to some criteria.

\vsp

In our context, the problem space $\mathcal{P}$ consists of datasets that require sorting. An instance $x \in \mathcal{P}$ is a list to be sorted. The feature space $\mathcal{F}$ comprises measurable characteristics of these datasets, such as size, distribution patterns, Shannon entropy \cite{shannonentropy}, and, most importantly, measures of presortedness. These measures tell us the pre-existing order of a given list \cite{Mannila1985MeasuresOP}.

The algorithm space $\mathcal{A}$ includes various sorting algorithms like QuickSort, MergeSort, InsertionSort, and others. For simplicity, our performance space is defined as $\{0,1\}$, where a value of 1 indicates that the selection algorithm has correctly identified the fastest sorter for a given problem instance.

\vsp

\noindent \textbf{Given:}
\begin{itemize}
    \item Datasets $\mathcal{P} \ni x$, where $x$ is a list that requires sorting.
    \item A feature space $\mathcal{F}$, where each $f(x) \in \mathcal{F}$ represents measurable characteristics of a list $x \in \mathcal{P}$.
    \item An algorithm space $\mathcal{A}$, containing all applicable sorting algorithms $A_i$.
    \item A performance space $\{0,1\}$, where the performance metric is defined as
    \[
    p(A_i, x) = 
    \begin{cases}
    1, & \text{if } A_i \text{ is the fastest sorter for } x, \\
    0, & \text{otherwise.}
    \end{cases}
    \]
\end{itemize}

\noindent \textbf{Find:} A selection mapping
\[
S: \mathcal{F} \rightarrow \mathcal{A}
\]
that maximizes the average number of fastest sorter selections, i.e.,
\[
\max_{S} \frac{1}{|\mathcal{P}|} \sum_{x \in \mathcal{P}} p(S(f(x)), x).
\]


\section{Methodology}

A good measure of presortedness must satisfy the following criteria:
\noindent \emph{Let $m$ be a measure of presortedness, and $X, Y$ be lists}:
\begin{enumerate}
    \item $m(X) = 0$ if $X$ is \emph{fully sorted in ascending order}.
    \item if $X = [x_1, \cdots, x_n], Y= [y_1, \cdots, y_n]$ and \\
    $x_i < x_j$ iff $y_i < y_j$ for all $i$ and $j$, then $m(X) = m(Y)$. 
    \item if $X \subseteq Y, m(X) \leq m(Y)$.
    \item if $X < Y$, then $m(XY) \leq m(X) + m(Y)$.
    \item \emph{For any element} $a$, $m(a + X) \leq |X| + m(X)$.
\end{enumerate}

\bibliographystyle{plain}
\bibliography{references}

\end{document} 